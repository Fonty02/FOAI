\section{Exercise 1}

\subsection{Overview}

This document provides a detailed description of the updates performed. The modifications have been structured into two main sections: firstly, the upload of various entities to specific classes, and secondly, the improvements proposed for the the interface.

\subsection{Data Upload Details}


\begin{itemize}
    \item \textbf{Metal Slug Series - Main Games}: Approximately 10 main titles from the Metal Slug series  \textit{RETROCOMPUTING $\rightarrow$ VIDEOGAME}
    \item \textbf{Flight Simulator Series}: Around 10 flight simulation games.  \textit{RETROCOMPUTING $\rightarrow$ VIDEOGAME}
    \item \textbf{Street Fighter Series}: Roughly 8 distinct titles.  \textit{RETROCOMPUTING $\rightarrow$ VIDEOGAME}
    \item \textbf{Dragon Ball Games}: About 15 games.  \textit{RETROCOMPUTING $\rightarrow$ VIDEOGAME}
    \item \textbf{Pro Evolution Soccer Series}: Nearly 35 games including both current titles and their historical predecessors.  \textit{RETROCOMPUTING $\rightarrow$ VIDEOGAME}
    \item \textbf{Console Games}: Approximately 5 devices.  \textit{RETROCOMPUTING $\rightarrow$ CONSOLE}
    \item \textbf{Technology Vendors}: Details for 5 companies.  \textit{RETROCOMPUTING $\rightarrow$ COMPANY}
    \item \textbf{Peripheral Devices}: Information for about 15 mouse and keyboard devices.  \textit{RETROCOMPUTING $\rightarrow$ Input Device   (Mouse, Keyboard)}
    \item \textbf{EXPO Events}: A list of approximately 35 events. \textit{RETROCOMPUTING $\rightarrow$ Event}
    \item \textbf{Software Relationships}: For each videogame, a \textit{producedBy} relationship has been established linking the software to the company that developed it.
    \item \textbf{Console Relationships}: For each console, the producing company has been recorded along with associated relationships to already existing consoles.
    \item \textbf{Peripheral Relationships}: For each mouse and keyboard device, the producer has been identified.
    \item \textbf{Geographical Data}: Inclusion of Matera and surrounding cities (approximately 30 locations).
    \item \textbf{Internet Protocols}: Updates include renaming 8 existing protocols and adding around 70 new entries.  \textit{RETROCOMPUTING $\rightarrow$ InternetProtocol}
    \item \textbf{Crapiata}: A traditional dish from Matera, described as a soup made with legumes and vegetables, albeit missing some ingredients.   \textit{FOOD}
    \item \textbf{Culinary Relationships}: Established relevant relationships associated with the aforementioned dish.
\end{itemize}



\subsection{Interface Improvements}

Several adjustments have been made to enhance the user interface:

\begin{itemize}
    \item Incorporation of an HTML Date Type field for the insertion of dates.
    \item Modification of the relationship creation process to allow starting from either the Subject or the Object.
\end{itemize}


\section{Exercise 2, with Cirilli Davide}

\subsection{Overview}

This report describes the modification proposed for several ontologies and the Java code provided in the \texttt{CsvToJsonConverter} package. Its objective is to explain in detail the purpose of the code, its functionality, and provide a higher-level overview of its implementation. The code is designed to read data from a CSV file, interpret it according to specific logic, transform it into a structured data model (entities and relationships), and finally serialize this model into a JSON file.


\subsection{Ontology Modifications}


Here we will provide a brief overview of the changes made the ontology. The modifications are divided by domains and, for each domain, they are divided into two subsections: the first one is about the entities and the second one is about the reletionships
\subsubsection{RETROCOMPUTING}

\paragraph{Entities}
\begin{itemize}
    \item \textbf{StorageMedium}: We suggest to add a new value for \textit{StorageMedium} called \textit{SolidState}. This value will be used to represent all the solid state storage devices such as SSD, USB pen drive and so on.
    \item \textbf{FPGA}: We suggest to add a new sub-class of \textit{Device} called \textit{FPGA}. This class will be used to represent all the FPGA devices, such as Microchip IGLOO Series
    \item \textbf{Videogame}: Since a videogame can be classified into multiple categories, We suggest to add an attribute to videogame called \textit{Category} that will be a list of categorie such as FPS, Sport, RPG, MOBa and so on. The previously existing sub-classes of \textit{Videogame} have been removed.
    \item \textbf{Preservation Project}: We suggest to add a new class called \textit{PreservationProject} sub-class of \textit{Artifact}. This class will be used to represent all the preservation projects that are related to retrocomputing for example \textit{Internet Archive} or \textit{MAME}. The new attributes are goal (mandatory) and description 
    \item \textbf{Fix}: We suggest to introduce 2 new attributes to \textit{Fix} which are \textit{repairDifficulty} that can assume only 3 values (Beginner, Intermediate, Expert) and \textit{documentationLink} that is a link to the documentation of the fix.
\end{itemize}

\paragraph{Relationships}
\begin{itemize}
\item \textbf{supports}: We suggest to add this new relationship between \textit{Device} (subject) and \textit{Software} (object). This relationship will be used to represent the software that is supported by a specific device. The attribute is compatibilityNotes
\item \textbf{compatibleWith}: We suggest to add Software (subject) and Component (object). This relationship will be used to represent the software that is compatible with a specific component.
\item \textbf{supports}: We suggest to add this new relationship between \textit{Device} / \textit{OperatingSystem} (subject)and \textit{Software} (object). This relationship will be used to represent the software that is supported by a specific device or operating system. The attribute is compatibilityNotes
\end{itemize}

\subsubsection{FOOD}
\paragraph{Entities}
\begin{itemize}
    \item \textbf{Beverage}: We suggest to add a new attribute called \textit{Type} to indicate the type of beverage (alcoholic, non-alcoholic, etc.).
    \item \textbf{Menu Item}: We suggest to add a new attribute called \textit{dietaryInfo} to indicate the dietary information of the menu item (vegan, vegetarian, gluten-free, etc.).
    \item \textbf{SensorialFeature}: Sensorial feature has been removed \footnote{Sensorial Feature may be described as attributes in a relationships without a specific class.}
    \item \textbf{Restaurant}: We suggest to add the attribute \textit{type} to indicate the type of restaurant (fast food, fine dining, etc.).
    \item \textbf{DietaryRestriction}: We suggest to add this new entity to represent the dietary restrictions that can be associated with a food item or menu item. The new attributes are name (mandatory) that can assume fixed values (vegan, vegetarian, gluten-free, etc.) 
    \item \textbf{KitchenTool}: We suggest to add this new entity to represent the kitchen tools that can be used in the preparation of food. The new attributes are name (mandatory)
\end{itemize}

\paragraph{Relationships}
\begin{itemize}
    \item \textbf{contains}: We suggest to add this new relationship between \textit{FoodBeverage} (subject) and \textit{Nutrient} (object). This relationship will be used to represent the nutrients that are contained in a specific food or beverage. The attribute is quantity (mandatory) that can assume fixed values (low, medium, high).
    \item \textbf{requires}: The subject has been modified from \textit{Artifact} to \textit{KitchenTool}
    \item \textbf{describes}: New attributes have been added to express SensorialFeature 
\end{itemize}

\subsubsection{OpensScience}

We've added the instruction <import schema "retrocomputing"> to the ontology to import the retrocomputing schema

\paragraph{Entities}
\begin{itemize}
    \item \textbf{Dataset}: We suggest to add new attributes: creationDate,license,format
    \item \textbf{Environment}: We suggest to add new attributes: type (whose values are Lab, Field or Virtual) and description
    \item \textbf{Author}: We suggest to add \textit{Author} as a sub-class of \textit{Person}
\end{itemize}

\subsubsection{General}
\paragraph{Entities}
\begin{itemize}
    \item \textbf{Material}: We suggest to add a new Category called \textit{Material} to represent the materials that can be used to describe Item.
    \item \textbf{Document}: We suggest to add a new attribute called \textit{ToC} to represent the table of contents of the document.
    \item \textbf{Item}: We suggest to add a new attribute called \textit{conditionNotes} to represent the condition of the item
\end{itemize}
\paragraph{Relationships}
\begin{itemize}
    \item \textbf{madeOf}: We suggest to add this new relationship between \textit{Item} (subject) and \textit{Material} (object)
\end{itemize}

% --- Purpose of the Code ---
\subsection{Purpose of the Code}
The primary purpose of the \texttt{CsvToJsonConverter} code is to convert a data catalog stored in a tabular CSV (Comma Separated Values) format into a hierarchical and structured JSON (JavaScript Object Notation) format.

More specifically, the code aims to:
\begin{itemize}
    \item Read data from a specific CSV file (\texttt{HCLEcatalog.csv}).
    \item Interpret each CSV row as representing a primary entity, classifying it definitively as either an \textbf{\texttt{Item}} or a \textbf{\texttt{Document}} based on specific criteria.
    \item Extract and map data from CSV columns to the fields of well-defined Java objects (POJOs - Plain Old Java Objects), representing Items, Documents, Persons, Organizations, Categories, and Materials.
    \item Apply data validation logic: If certain fields required for \texttt{Document} or \texttt{Item} identification or common fields are invalid or missing (null/empty/"None"), assign the literal string \textbf{\texttt{"N/A"}} to specific target fields (\texttt{toC}, \texttt{extent}, \texttt{serialNum}, \texttt{bibCit}, \texttt{created} for Documents; \texttt{partNum} for Items). Other fields are populated only if valid, otherwise left null.
    \item Identify and create related entities such as persons (\texttt{Person}), organizations (\texttt{Organization}), categories (\texttt{Category}), and materials (\texttt{Material}) from data in other columns (e.g., \texttt{Creator}, \texttt{SubjectTop}, \texttt{Material}).
    \item Establish meaningful relationships between these entities (e.g., an \texttt{Item} "belongsTo" a collection, a \texttt{Document} is "developed by" a \texttt{Person}, an \texttt{Item} is "madeOf" a \texttt{Material}). Note that relationship identifiers involving Items now incorporate the \texttt{partNum}, which might be "N/A".
    \item Ensure the uniqueness of the extracted entities and relationships (avoiding duplicates) using Java Sets.
    \item Generate a log file (\texttt{parsing.log}) that tracks the processing status and reports any errors or warnings for each CSV row.
    \item Produce a final JSON file (\texttt{data.json}) representing all unique entities (Items, Documents, Persons, etc.) and their relationships in a well-defined structure, suitable for further processing, analysis, or integration with other systems.
\end{itemize}
In summary, the code acts as a bridge between a tabular CSV format and a structured JSON format, applying domain-specific classification logic (Item vs. Document) and specific rules for handling missing/invalid data ("N/A" assignment).

% --- Main Functionality (What it Does) ---
\subsection{Main Functionality (What it Does)}
The code executes a series of logical steps to achieve its purpose:

\begin{enumerate}
    \item \textbf{CSV Reading and Parsing:}
        \begin{itemize}
            \item Opens the specified CSV file (\texttt{HCLEcatalog.csv}) using UTF-8 encoding.
            \item Utilizes the Apache Commons CSV library to interpret the file.
            \item Recognizes the first row as the header, ignoring case in column names.
            \item Trims leading and trailing whitespace from each read value.
            \item Iterates over each record (row) in the CSV file, excluding the header.
        \end{itemize}

    \item \textbf{Row Validation and Data Extraction:}
        \begin{itemize}
            \item For each row, extracts the value from the \texttt{IdNum} column. If it is missing or effectively empty, the row is skipped, and an error is logged.
            \item Extracts values from all other columns defined in the header and stores them in a map (\texttt{Map<String, String>}) for easy access. Values are stored as extracted (null if missing).
        \end{itemize}

    \item \textbf{Determining the Main Entity Type (Document or Item):}
        \begin{itemize}
            \item By checking \textit{ToC}, \textit{Extent}, \textit{SerialNum}, \textit{BibCit} and \textit{PartNum} we are able to determine if the row represents a \texttt{Document} or an \texttt{Item}. 
        \end{itemize}

    \item \textbf{Creating the Main Entity Object (Document or Item):}
        \begin{itemize}
            \item Instantiates a Java object of the determined class (\texttt{Document} or \texttt{Item}).
            \item Populates the object's fields with values extracted from the corresponding CSV columns, applying specific "N/A" logic:
                \begin{itemize}
                    \item \textbf{For Documents:}
                        \begin{itemize}
                        \item Sets \texttt{toC}, \texttt{extent}, \texttt{serialNum}, \texttt{bibCit} fields to the string \textbf{\texttt{"N/A"}} if the corresponding CSV value is null, empty, or "None". Otherwise, uses the valid CSV value.
                        \item Sets \texttt{created} field: Uses the value from \texttt{Created}, falls back to \texttt{DateCR}, then sets to \textbf{\texttt{"N/A"}} if the resulting value is null, empty, or "None". Otherwise, uses the valid date string.
                        \item Sets \texttt{copyrighted} field: Converts 'y' to \texttt{true}, 'n' or '0' to \texttt{false}. If the value is missing, invalid, or "None", the field remains \texttt{null} (no "N/A" applied).
                        \end{itemize}
                    \item \textbf{For Items:}
                        \begin{itemize}
                        \item Sets \texttt{partNum} field: Sets to the string \textbf{\texttt{"N/A"}} if the corresponding CSV value is null, empty, "None", or consists of only a single digit. Otherwise, uses the valid CSV value.
                        \item Sets \texttt{conditionNts} field only if the corresponding CSV value is valid (not null, empty, or "None"). 
                        \end{itemize}
                    \item \textbf{For Common Fields (Description, DescComment, WherMade):} Populates these fields on the \texttt{Document} or \texttt{Item} object only if the corresponding CSV value is valid (not null, empty, or "None").
                \end{itemize}
        \end{itemize}

    \item \textbf{Identifying and Creating Related Entities:}
        \begin{itemize}
            \item \textbf{Material:} If the \texttt{Material} column contains 'papr', 'digi', or 'mix', creates a \texttt{Material} object ("paper", "digital", "mix").
            \item \textbf{Category:} If the \texttt{SubjectTop} column has a valid value, creates a \texttt{Category} object.
            \item \textbf{Person/Organization (from Creator, Contributor, AddlAuth):} Logic remains the same as previous description (using regex, \texttt{parsePerson}, \texttt{processContributorField}) to create \texttt{Person} or \texttt{Organization} objects.
        \end{itemize}

    \item \textbf{Uniqueness Management:}
        \begin{itemize}
            \item Utilizes \texttt{HashSet} collections for \texttt{Item}, \texttt{Document}, \texttt{Person}, \texttt{Organization}, \texttt{Category}, \texttt{Material}, and \texttt{Relationship}.
            \item Ensures uniqueness based on the \texttt{equals()} and \texttt{hashCode()} methods in the POJO classes.
        \end{itemize}

    \item \textbf{Relationship Creation:}
        \begin{itemize}
            \item \textbf{\texttt{belongsTo}} (Collection -> Entity): Created for every valid \texttt{Item} or \texttt{Document}. The object identifier includes the title and, for Items, the \texttt{partNum} .
            \item \textbf{\texttt{madeOf}} (Item -> Material): Created only for \texttt{Item}s with an identified \texttt{Material}.
            \item \textbf{\texttt{describe}} (Category -> Document): Created \textbf{only} if the main entity is a \texttt{Document} and a \texttt{Category} was identified.
            \item \textbf{Creator Relationships} (\texttt{developed} / \texttt{produced}): Created \textbf{only} if the main entity is a \texttt{Document} and a \texttt{Creator} (Person/Organization) was identified.
            \item \textbf{Contributor/AddlAuth Relationships} (\texttt{developed}/\texttt{produced}/\texttt{collaborated}): Created for both \texttt{Item}s and \texttt{Document}s if contributors/authors are identified.
        \end{itemize}

    \item \textbf{Logging:}
        \begin{itemize}
            \item Continues to log processing status, errors (missing IdNum/Title), and warnings (unrecognized Material code, failed person parsing) to \texttt{parsing.log}.
            \item The summary log at the end
        \end{itemize}

    \item \textbf{JSON Output Generation:}
        \begin{itemize}
            \item Collects unique \texttt{Item}s and \texttt{Document}s (and other entity types) into the \texttt{Entities} container.
            \item Filters relationships based on the validity of essential fields (as before).
            \item Creates the root \texttt{JsonOutput} object.
            \item Serializes the \texttt{JsonOutput} object to \texttt{data.json} using Jackson, producing formatted JSON. Fields with `"N/A"` values are included as strings.
        \end{itemize}

    \item \textbf{Error Handling:}
        \begin{itemize}
            \item Continues to use try-with-resources and catch blocks for robust file handling and error reporting.
        \end{itemize}
\end{enumerate}

% --- Implementation Overview (How it Works) ---
\subsection{Implementation Overview (How it Works)}
This section provides a high-level view of how the code achieves the updated functionality.

\begin{itemize}
    \item \textbf{External Libraries:} Still relies on Apache Commons CSV and Jackson Databind.

    \item \textbf{POJO-Based Structure:} The data model uses POJOs (\texttt{Item}, \texttt{Document}, \texttt{Person}, etc.). The \texttt{Artifact} class now primarily serves as a \textbf{base class} providing common fields (like \texttt{title}, \texttt{description}) inherited by \texttt{Item} and \texttt{Document}. Specific fields in \texttt{Item} and \texttt{Document} are now defined to potentially hold the string `"N/A"`. \texttt{equals()}/\texttt{hashCode()} are essential for uniqueness in Sets.

    \item \textbf{Main Class and Control Flow:} The \texttt{CsvToJsonConverter} class orchestrates the process. The core loop iterates through CSV records. The entity type determination logic is simplified to a binary choice (Document or Item). Logic for populating fields now includes checks for assigning `"N/A"` based on the rules.

    \item \textbf{Conditional Logic and Regex:} Entity classification is now based on the presence of specific Document-related fields. If not a Document, it's an Item. Part number validation for Items also uses a simple regex check (\texttt{\^{}\textbackslash{}d\$}). Regex for parsing person names remains the same.

    \item \textbf{Use of Standard Collections:} Continues to use \texttt{Map} for row data, \texttt{Set} for uniqueness, and \texttt{List} for the final JSON structure.

    \item \textbf{File and Resource Management:} Try-with-resources and UTF-8 encoding are maintained for proper resource handling and character support.
\end{itemize}

% --- Definition of Entities and Relationships ---
\subsection{Definition of Entities and Relationships}
The code defines the following main data structures (POJOs), with modifications noted:

\begin{itemize}
    \item \textbf{\texttt{BaseEntity}}: Abstract base class (unchanged).
    \item \textbf{\texttt{Artifact}}: Base class for Item and Document, providing common fields.
    \item \textbf{\texttt{Item}}: Subclass of \texttt{Artifact}. Represents a physical object. \texttt{partNum} field \textbf{can hold the string "N/A"}. \texttt{entityType} is "Item".
    \item \textbf{\texttt{Document}}: Subclass of \texttt{Artifact}. Represents a document. \texttt{toC}, \texttt{extent}, \texttt{serialNum}, \texttt{bibCit}, \texttt{created} fields \textbf{can hold the string "N/A"}. \texttt{entityType} is "Document".
    \item \textbf{\texttt{Person}}: Represents a person (unchanged). \texttt{entityType} is "Agent:Person".
    \item \textbf{\texttt{Organization}}: Represents an organization (unchanged). \texttt{entityType} is "Agent:Organization".
    \item \textbf{\texttt{Category}}: Represents a category (unchanged). \texttt{entityType} is "ContentDescription:Category".
    \item \textbf{\texttt{Material}}: Represents material (unchanged). \texttt{entityType} is "Material".
    \item \textbf{\texttt{Relationship}}: Represents a connection. Identifiers for Item subjects/objects now incorporate the potentially "N/A" \texttt{partNum}.
    \item \textbf{\texttt{CollectionInfo}}: Represents collection info (unchanged).
    \item \textbf{\texttt{Entities}}: Container grouping lists of entities.
    \item \textbf{\texttt{JsonOutput}}: Root object for JSON output (unchanged structure).
\end{itemize}
Jackson annotations control JSON serialization, including the omission of null fields and the inclusion of fields containing `"N/A"`.


\subsection{Estimation of the errors}
The primary objective of this analysis was to perform a qualitative assessment of the data quality within the provided JSON file, identifying common error patterns, inconsistencies.
\newline
The assessment was conducted primarily through manual inspection and pattern analysis of the `Entities` and `Relationships` sections within the JSON data.

\subsubsection{Creators and contributors}
Here a resume about errors between Person and Organization
\begin{table}[h]
    \centering
    \begin{tabular}{|c|c|c|}
        \hline
        Classified as $\downarrow$ / Actual $\rightarrow$ & Person & Organization \\
        \hline
        Person &  \textcolor{green}{\textbf{n}} (Correct) & \textcolor{red}{\textbf{13}} (Incorrect) \\
        \hline
        Organization & \textcolor{red}{\textbf{71}} (Incorrect) &  \textcolor{green}{\textbf{m}} (Correct) \\
        \hline
    \end{tabular}
    \caption{Confusion matrix for People/Organizations classification}
    \label{tab:people_org}
\end{table}
\newline
This suggests a potential issue in the original data source.





\subsubsection{Summary}
\begin{itemize}
    \item \textbf{Entity Misclassification (People/Orgs):} 84 instances error estimated.
    \item \textbf{Placeholder/Incomplete Data:} Affects dozens to hundreds of records.
    \item \textbf{Formatting Inconsistencies:} Pervasive across relevant fields and records.
\end{itemize}
