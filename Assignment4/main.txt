\documentclass[12pt,a4paper]{article}
% Packages
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb}
\usepackage{graphicx}
\usepackage[hidelinks]{hyperref}
\usepackage{authblk} % Package for multiple authors
\usepackage{booktabs} % For better tables
\usepackage{listings} % For code snippets
\usepackage{xcolor} % For colored text
\usepackage{float} % For better figure placement with [H]
% Define Prolog language style for listings
\definecolor{prologcomment}{rgb}{0.5,0.5,0.5} % Gray for comments
\definecolor{prologkeyword}{rgb}{0,0,0.8} % Blue for keywords/predicates
\definecolor{prologstring}{rgb}{0.8,0,0} % Red for strings/atoms
\definecolor{prologvariable}{rgb}{0,0.5,0} % Green for variables
\lstdefinestyle{prologstyle}{
language=Prolog,
basicstyle=\ttfamily\small,
keywordstyle=\color{prologkeyword}\bfseries,
commentstyle=\color{prologcomment},
stringstyle=\color{prologstring},
identifierstyle=\color{prologvariable}, % Style for variables
morekeywords={node, arc, edge, find_simple_cycles, generate_edges, find_all_elementary_cycles, dfs_find_cycle, filter_simple_cycles, is_simple_cycle, check_all_pairs_shortest_path, check_pairs_from_node, get_cycle_distance, shortest_path_length, bfs, add_neighbors_to_queue, normalize_cycle, find_min_node, rotate_list_to_start_with, print_cycles_list, print_cycles_list_reversed, member, length, writeln, write, nl, retractall, forall, assertz, findall, reverse, append, nth0, list_to_set, setof, main, setup_test, read, halt}, % Added new main predicates
morecomment=[l]{//}, % Line comments starting with //
morecomment=[l]{%}, % Line comments starting with %
morestring=[b]', % Single quoted strings/atoms
morestring=[b]", % Double quoted strings (less common in Prolog)
showstringspaces=false,
tabsize=2,
breaklines=true,
breakatwhitespace=true,
captionpos=b, % Position caption below the listing
frame=single % Add a frame around the code
}
% Title and author information
\title{Finding Simple Cycles in a Directed Graph using Prolog}
\author[1]{Cirilli Davide}
\author[2]{Fontana Emanuele}
\affil[1,2]{Department of Computer Science, Universit√† degli Studi di Bari}
\begin{document}
\maketitle
\begin{abstract}
This document describes a Prolog program designed to identify all "simple cycles" within a directed graph. The program features an interactive main predicate that allows selection from predefined test cases. For a chosen graph, it first finds all elementary cycles and then filters them based on a specific shortest path criterion to determine simplicity. The implementation utilizes Depth-First Search (DFS) for cycle detection and Breadth-First Search (BFS) for shortest path calculations.
\end{abstract}
\tableofcontents
\section{Introduction}
A cycle in a directed graph is a path that starts and ends at the same node. An \textit{elementary cycle} is a cycle where no node (except the start/end node) appears more than once. This program aims to find a subset of elementary cycles termed "simple cycles".
A cycle is defined as \textit{simple} if, for any two distinct nodes 
u
u
 and 
v
v
 within the cycle, the shortest path from 
u
u
 to 
v
v
 in the \textit{entire graph} is the path that follows the edges of the cycle itself. If a shorter path (a "shortcut") exists between 
u
u
 and 
v
v
 using edges outside the cycle, the cycle is not considered simple.
This program implements this definition using Prolog, leveraging its backtracking capabilities for graph traversal and dynamic fact manipulation for setting up different graph structures.
\section{Implementation Details}
The Prolog program (\texttt{simpleCycle.pl}) begins with directives:
\begin{verbatim}
:- dynamic node/2.
:- dynamic arc/4.
:- dynamic edge/2.
\end{verbatim}
The \texttt{:- dynamic Predicate/Arity} directive declares that facts for \texttt{node/2}, \texttt{arc/4}, and the helper \texttt{edge/2} can be added (\texttt{assertz}) or removed (\texttt{retractall}) during program execution. This is crucial for the \texttt{setup_test/1} predicate, which defines different graph structures, and for \texttt{generate_edges/0}, which dynamically creates \texttt{edge/2} facts.
The program consists of several key components:
\subsection{Graph Representation and Setup}
The graph is primarily defined by \texttt{arc/4} facts, which are dynamically asserted by test case setup predicates.
\begin{itemize}
\item \texttt{node(NodeID, Type)}: Declares a node with a unique ID and an associated type. While test cases primarily define connectivity through \texttt{arc/4} facts, default \texttt{node/2} facts are provided in the code. These are used by \texttt{find_all_elementary_cycles/1} to gather an initial list of all potential starting nodes for cycle detection.
\item \texttt{arc(ArcID, Type, SourceNode, TargetNode)}: Declares a directed arc with a unique ID, type, source node, and target node. These facts define the graph's structure for a given test case.
\item \texttt{setup_test/1}: A predicate responsible for configuring the graph for a chosen test case (1, 2, 3, or 4). It first calls \texttt{retractall(arc(_, _, _, _))} to clear any existing arc definitions and then asserts the specific \texttt{arc/4} facts for the selected test case.
\end{itemize}
For traversal efficiency, a helper predicate \texttt{edge(Source, Target)} is dynamically generated from the current \texttt{arc/4} facts.
\begin{itemize}
\item \texttt{generate_edges/0}: This predicate prepares the graph for traversal.
\begin{itemize}
\item It first calls \texttt{retractall(edge(_, _))} to remove any existing \texttt{edge/2} facts, ensuring a clean state corresponding to the current set of \texttt{arc/4} facts.
\item Then, \texttt{forall(arc(_, _, N, M), assertz(edge(N, M)))} iterates through all current \texttt{arc/4} facts. For each, it extracts the source (\texttt{N}) and target (\texttt{M}) nodes and asserts a new fact \texttt{edge(N, M)}. This provides faster lookups for direct connections.
\end{itemize}
\end{itemize}
\subsection{Finding Elementary Cycles}
Elementary cycles are found using a Depth-First Search (DFS) approach:
\begin{itemize}
\item \texttt{find_all_elementary_cycles/1}: The main predicate for this stage.
\begin{itemize}
\item It uses \texttt{findall(N, node(N, _), Nodes)} to collect all \texttt{NodeID}s from the currently asserted \texttt{node/2} facts into the list \texttt{Nodes}. These nodes serve as potential starting points for cycles.
\item It then calls \texttt{find_cycles_starting_from_nodes/2} with this list.
\item The argument \texttt{Cycles} will be unified with the list of all elementary cycles found.
\end{itemize}
\item \texttt{find_cycles_starting_from_nodes/2}: Iterates through all nodes from the \texttt{Nodes} list and initiates DFS from each.
\begin{itemize}
\item It uses \texttt{findall/3}. The template is \texttt{Cycle}.
\item The goal is \texttt{(member(StartNode, Nodes), edge(StartNode, Neighbor), dfs_find_cycle(Neighbor, StartNode, [Neighbor, StartNode], Cycle))}.
\item \texttt{member(StartNode, Nodes)} iterates through each node as a potential starting point.
\item \texttt{edge(StartNode, Neighbor)} finds a node directly reachable from \texttt{StartNode}.
\item \texttt{dfs_find_cycle/4} is called to perform DFS starting from this \texttt{Neighbor}, aiming to return to \texttt{StartNode}. The path is initialized with \texttt{[Neighbor, StartNode]}.
\item \texttt{findall/3} collects all \texttt{Cycle} bindings found through backtracking.
\end{itemize}
\item \texttt{dfs_find_cycle/4}: Performs the recursive DFS: \texttt{dfs_find_cycle(CurrentNode, TargetNode, PathSoFar, Cycle)}.
\begin{itemize}
\item It looks for an edge from \texttt{CurrentNode} to \texttt{NextNode} using \texttt{edge(CurrentNode, NextNode)}.
\item Base Case: If \texttt{NextNode == TargetNode}, the starting node is reached. \texttt{Cycle} is unified with \texttt{[TargetNode | PathSoFar]}.
\item Recursive Step: If \texttt{NextNode} is not \texttt{TargetNode}, it checks \texttt{\+ memberchk(NextNode, PathSoFar)} to ensure elementarity. If not visited in the current path, it recursively calls \texttt{dfs_find_cycle(NextNode, TargetNode, [NextNode | PathSoFar], Cycle)}.
\end{itemize}
\item Cycles from DFS are returned in reverse traversal order (e.g., \texttt{[a, d, c, b, a]} for a cycle a 
/rightarrow
/rightarrow
 b 
/rightarrow
/rightarrow
 c 
/rightarrow
/rightarrow
 d 
/rightarrow
/rightarrow
 a).
\end{itemize}
\subsection{Filtering for Simple Cycles}
The logic for identifying simple cycles:
\begin{itemize}
\item \texttt{filter_simple_cycles/2}: Takes \texttt{ElementaryCycles} and returns \texttt{NormalizedSimpleCycles}.
\begin{itemize}
\item Base Case: \texttt{filter_simple_cycles([], [])}.
\item Recursive Step 1 (Simple Cycle Found): If \texttt{is_simple_cycle(Cycle)} succeeds for the head \texttt{Cycle}, it's cut (\texttt{!}), normalized via \texttt{normalize_cycle(Cycle, NormalizedCycle)}, and prepended to the result of recursively processing \texttt{RestCandidates}.
\item Recursive Step 2 (Not Simple): If \texttt{is_simple_cycle(Cycle)} fails, the \texttt{_Cycle} is ignored, and the predicate recurses on \texttt{RestCandidates}.
\end{itemize}
\item \texttt{is_simple_cycle/1}: Checks if an elementary cycle is simple.
\begin{itemize}
\item Reverses the DFS cycle: \texttt{reverse(Cycle, ForwardCycleWithRepeatEnd)}.
\item Deconstructs to get ordered unique nodes: \texttt{ForwardCycleWithRepeatEnd = [StartNode | PathNodesWithRepeatEnd]}, \texttt{append(PathNodesUnique, [StartNode], PathNodesWithRepeatEnd)}, \texttt{NodesInCycleOrdered = [StartNode | PathNodesUnique]}. E.g., for DFS output \texttt{[a,c,b,a]}, this yields \texttt{[a,b,c]}.
\item Calls \texttt{check_all_pairs_shortest_path(NodesInCycleOrdered, NodesInCycleOrdered)}.
\end{itemize}
\item \texttt{check_all_pairs_shortest_path/2}: Iterates through ordered pairs 
(
u
,
v
)
(u,v)
 in \texttt{NodesInCycleOrdered}.
\begin{itemize}
\item Base Case: \texttt{check_all_pairs_shortest_path([], _)}.
\item Recursive Step: Takes \texttt{N1} from the list, calls \texttt{check_pairs_from_node(N1, OriginalCycleNodes, OriginalCycleNodes)}, then recurses on \texttt{RestN1}.
\end{itemize}
\item \texttt{check_pairs_from_node/3}: For a given \texttt{N1}, iterates through other nodes \texttt{N2} in \texttt{OriginalCycleNodes}.
\begin{itemize}
\item Base Case: \texttt{check_pairs_from_node(_, [], _)}.
\item Recursive Step: Takes \texttt{N2}.
\item If \texttt{N1 == N2}, skip (\texttt{true}).
\item Else, calculate \texttt{get_cycle_distance(N1, N2, OriginalCycleNodes, CycleDist)} and \texttt{shortest_path_length(N1, N2, ShortestDist)}.
\item Check simplicity:
\begin{itemize}
\item If \texttt{ShortestDist == -1} (no path in graph), then \texttt{CycleDist > 0} must hold (or \texttt{!, fail}).
\item Else (path exists), \texttt{ShortestDist >= CycleDist} must hold.
\end{itemize}
\item If the check succeeds, cut (\texttt{!}) and recurse on \texttt{RestN2}.
\item Failure Clause: \texttt{check_pairs_from_node(_, _, _) :- !, fail.} ensures immediate failure if any pair violates simplicity.
\end{itemize}
\item \texttt{get_cycle_distance/4}: Calculates distance from \texttt{NodeA} to \texttt{NodeB} along \texttt{CycleNodes}.
\begin{itemize}
\item Finds indices \texttt{IndexA}, \texttt{IndexB} using \texttt{nth0/3}. Gets \texttt{length(CycleNodes, Len)}.
\item If \texttt{IndexB >= IndexA}, \texttt{Distance is IndexB - IndexA}.
\item Else, \texttt{Distance is Len - IndexA + IndexB}.
\end{itemize}
\item \texttt{shortest_path_length/3}: Finds shortest path length between \texttt{Start} and \texttt{End} using BFS.
\begin{itemize}
\item Calls \texttt{bfs([[Start, 0]], End, [Start], Length)}.
\item Cuts (\texttt{!}) on success. If BFS fails, the second clause \texttt{shortest_path_length(_, _, -1)} sets \texttt{Length} to -1.
\end{itemize}
\item \texttt{bfs/4}: Standard BFS: \texttt{bfs(Queue, Target, Visited, Length)}.
\begin{itemize}
\item Base Case 1 (Queue Empty): \texttt{bfs([], _, _, _) :- !, fail.}
\item Base Case 2 (Target Found): \texttt{bfs([[Target, Length] | _], Target, _, Length) :- !.}
\item Recursive Step: Dequeues \texttt{[Current, Dist]}. Finds unvisited neighbors via \texttt{findall(Next, (edge(Current, Next), \+ member(Next, Visited)), Neighbors)}. Calculates \texttt{NewDist is Dist + 1}. Adds neighbors to queue via \texttt{add_neighbors_to_queue/4}. Updates visited list (using \texttt{append/3} and \texttt{list_to_set/2}). Recurses.
\end{itemize}
\item \texttt{add_neighbors_to_queue/4}: Formats neighbors as \texttt{[Node, Distance]} and appends to queue using \texttt{findall/3} and \texttt{append/3}.
\end{itemize}
\subsection{Cycle Normalization}
Ensures unique representation for identical cycles starting at different nodes.
\begin{itemize}
\item \texttt{normalize_cycle/2}: Converts raw DFS cycle \texttt{RawCycle} (e.g., \texttt{[a,d,c,b,a]}) to \texttt{NormalizedNodeList}.
\item Process:
1. Deconstruct: \texttt{RawCycle = [StartNode | ReversedPathWithStart]}.
2. Get forward path nodes: \texttt{reverse(ReversedPathWithStart, [_ | ForwardPathNodes])}.
3. Reconstruct forward cycle nodes: \texttt{ForwardCycleNodes = [StartNode | ForwardPathNodes]} (e.g., \texttt{[a,b,c,d]}).
4. Find minimum node: \texttt{find_min_node(ForwardCycleNodes, MinNode)}.
5. Rotate: \texttt{rotate_list_to_start_with(ForwardCycleNodes, MinNode, NormalizedNodeList)}.
\item \texttt{find_min_node/2}: Finds minimum node in a list using \texttt{@<}.
\begin{itemize}
\item Base Case: \texttt{find_min_node([M], M) :- !.}
\item Recursive Step: Compares head \texttt{H} with minimum of tail \texttt{MinTail}.
\end{itemize}
\item \texttt{rotate_list_to_start_with/3}: Rotates \texttt{List} so \texttt{Element} is first.
\begin{itemize}
\item Uses \texttt{append(BeforeElement, [Element | AfterElement], List), !, append([Element | AfterElement], BeforeElement, RotatedList)}.
\item Fallback clause: \texttt{rotate_list_to_start_with(List, _, List)} if element already first or not found (latter shouldn't occur in this program's logic).
\end{itemize}
\end{itemize}
The final list of simple cycles is produced using \texttt{setof/3} on the normalized cycles to ensure uniqueness and canonical order.
\subsection{Main Predicate and Output Control}
\begin{itemize}
\item \texttt{main/0}: The primary entry point for execution.
\begin{enumerate}
\item Prompts the user to select a test case (1-4) using \texttt{write/1} and \texttt{read/1}.
\item Calls \texttt{setup_test(N)} with the chosen number \texttt{N}.
\item If \texttt{setup_test/1} succeeds, it calls \texttt{find_simple_cycles(SimpleCycles)}.
\item Prints the resulting \texttt{SimpleCycles} list.
\item If an invalid test case number is entered, an error message is shown.
\item Calls \texttt{halt/0} to terminate the Prolog session.
\end{enumerate}
\item \texttt{find_simple_cycles/1}: Orchestrates the cycle finding and filtering process for the currently loaded graph.
\begin{enumerate}
\item Calls \texttt{generate_edges/0}.
\item Calls \texttt{find_all_elementary_cycles/1} to get \texttt{ElementaryCycles}.
\item Prints the count and list of elementary cycles (using \texttt{print_cycles_list_reversed/2} as DFS cycles are reversed).
\item If elementary cycles exist:
\begin{itemize}
\item Calls \texttt{filter_simple_cycles/2} to get \texttt{NormalizedSimpleCycles}.
\item Uses \texttt{setof(NormCycle, Member^(member(Member, NormalizedSimpleCycles), NormCycle = Member), SimpleCycles)} to get the final unique, sorted list.
\item Prints the simple cycles (using \texttt{print_cycles_list/2}) and their count.
\item If \texttt{setof/3} fails (no simple cycles), prints a message and sets \texttt{SimpleCycles} to \texttt{[]}.
\end{itemize}
\item If no elementary cycles, prints a message and sets \texttt{SimpleCycles} to \texttt{[]}.
\item The argument \texttt{SimpleCycles} is unified with the final list.
\end{itemize}
\item Helper Printing Predicates:
\begin{itemize}
\item \texttt{print_cycles_list/2}: \texttt{print_cycles_list(Header, ListOfCycles)}. Prints a header and then each cycle in the list, indented.
\item \texttt{print_cycles_list_reversed/2}: Similar to \texttt{print_cycles_list/2}, but it first reverses each cycle in the list before printing. This is used for displaying elementary cycles as found by DFS in their natural traversal order.
\end{itemize}
\end{itemize}
\section{Test Cases and Usage}
\subsection{Usage}
Ensure a Prolog interpreter (e.g., SWI-Prolog) is installed.
Load the program file: \texttt{?- [simpleCycle].} (or your filename).
Run the main interactive predicate: \texttt{?- main.}
The program will prompt: \texttt{Select test case (1, 2, 3, or 4):}
Enter a number from 1 to 4 and press Enter.
The program will then execute for the chosen test case, printing intermediate elementary cycles and the final list of unique, normalized simple cycles. The output will also show \texttt{SimpleCycles = [[...], ...]}.
The program will then halt.
\subsection{Predefined Test Cases}
The program includes four predefined test cases, set up by \texttt{setup_test/1}.
\subsubsection{Test Case 1: Simple Triangle}
\begin{itemize}
\item \textbf{Description:} A basic directed triangle: a 
/rightarrow
/rightarrow
 b 
/rightarrow
/rightarrow
 c 
/rightarrow
/rightarrow
 a.
\item \textbf{Arcs Defined:}
\begin{lstlisting}[style=prologstyle, basicstyle=\ttfamily\footnotesize]
assertz(arc(1, t, a, b)).
assertz(arc(2, t, b, c)).
assertz(arc(3, t, c, a)).
\end{lstlisting}
\item \textbf{Graph Visualization:}
\begin{figure}[H]
\centering
\includegraphics[width=0.4\textwidth]{graph_test_case_1.png} % Replace with actual image path
\caption{Graphical representation of Test Case 1.}
\label{fig:test_case_1}
\end{figure}
\item \textbf{Expected Simple Cycles:} \texttt{[[a,b,c]]}
\end{itemize}
\subsubsection{Test Case 2: Square with a Chord}
\begin{itemize}
\item \textbf{Description:} A square cycle a 
/rightarrow
/rightarrow
 b 
/rightarrow
/rightarrow
 c 
/rightarrow
/rightarrow
 d 
/rightarrow
/rightarrow
 a, with an additional "chord" arc b 
/rightarrow
/rightarrow
 d.
\item \textbf{Arcs Defined:}
\begin{lstlisting}[style=prologstyle, basicstyle=\ttfamily\footnotesize]
assertz(arc(1, t, a, b)).
assertz(arc(2, t, b, c)).
assertz(arc(3, t, c, d)).
assertz(arc(4, t, d, a)).
assertz(arc(5, t, b, d)). % The chord
\end{lstlisting}
\item \textbf{Graph Visualization:}
\begin{figure}[H]
\centering
\includegraphics[width=0.5\textwidth]{graph_test_case_2.png} % Replace with actual image path
\caption{Graphical representation of Test Case 2.}
\label{fig:test_case_2}
\end{figure}
\item \textbf{Expected Simple Cycles:} \texttt{[[a,b,d], [b,c,d]]}. The cycle \texttt{[a,b,c,d]} (from a 
/rightarrow
/rightarrow
 b 
/rightarrow
/rightarrow
 c 
/rightarrow
/rightarrow
 d 
/rightarrow
/rightarrow
 a) is elementary but not simple due to the shortcut b 
/rightarrow
/rightarrow
 d (path b 
/rightarrow
/rightarrow
 c 
/rightarrow
/rightarrow
 d has length 2, path b 
/rightarrow
/rightarrow
 d has length 1).
\end{itemize}
\subsubsection{Test Case 3: Disjoint Cycles}
\begin{itemize}
\item \textbf{Description:} A graph containing a 2-cycle (a 
/leftrightarrow
/leftrightarrow
 b) and two separate, non-overlapping triangles (c-d-e-c and d-f-g-d).
\item \textbf{Arcs Defined:}
\begin{lstlisting}[style=prologstyle, basicstyle=\ttfamily\footnotesize]
assertz(arc(1, t, a, b)). % 2-cycle
assertz(arc(2, t, b, a)).
assertz(arc(3, t, c, d)). % Triangle 1
assertz(arc(4, t, d, e)).
assertz(arc(5, t, e, c)).
assertz(arc(6, t, d, f)). % Triangle 2
assertz(arc(7, t, f, g)).
assertz(arc(8, t, g, d)).
\end{lstlisting}
\item \textbf{Graph Visualization:}
\begin{figure}[H]
\centering
\includegraphics[width=0.7\textwidth]{graph_test_case_3.png} % Replace with actual image path
\caption{Graphical representation of Test Case 3.}
\label{fig:test_case_3}
\end{figure}
\item \textbf{Expected Simple Cycles:} \texttt{[[a,b], [c,d,e], [d,f,g]]} (order by \texttt{setof} might vary but content is these three).
\end{itemize}
\subsubsection{Test Case 4: Complex Overlapping Cycles and Chord}
\begin{itemize}
\item \textbf{Description:} A more complex graph with two larger, overlapping cycles and a shortcut arc.
Cycle A: a 
/rightarrow
/rightarrow
 b 
/rightarrow
/rightarrow
 c 
/rightarrow
/rightarrow
 d 
/rightarrow
/rightarrow
 a.
Cycle B: b 
/rightarrow
/rightarrow
 e 
/rightarrow
/rightarrow
 d 
/rightarrow
/rightarrow
 c 
/rightarrow
/rightarrow
 b.
Chord: a 
/rightarrow
/rightarrow
 d.
This also creates smaller 2-cycles like b 
/leftrightarrow
/leftrightarrow
 c and c 
/leftrightarrow
/leftrightarrow
 d due to edges from both Cycle A and Cycle B.
\item \textbf{Arcs Defined:}
\begin{lstlisting}[style=prologstyle, basicstyle=\ttfamily\footnotesize]
assertz(arc(1, t, a, b)).
assertz(arc(2, t, b, c)).
assertz(arc(3, t, c, d)).
assertz(arc(4, t, d, a)).
assertz(arc(5, t, b, e)).
assertz(arc(6, t, e, d)).
assertz(arc(7, t, d, c)). % Edge for Cycle B, opposite of c->d in Cycle A
assertz(arc(8, t, c, b)). % Edge for Cycle B, opposite of b->c in Cycle A
assertz(arc(9, t, a, d)). % Chord for Cycle A
\end{lstlisting}
\item \textbf{Graph Visualization:}
\begin{figure}[H]
\centering
\includegraphics[width=0.6\textwidth]{graph_test_case_4.png} % Replace with actual image path
\caption{Graphical representation of Test Case 4.}
\label{fig:test_case_4}
\end{figure}
\item \textbf{Expected Simple Cycles:} \texttt{[[a,d], [b,c], [c,d]]}.
\begin{itemize}
\item \texttt{[a,b,c,d]} (from a 
/rightarrow
/rightarrow
 b 
/rightarrow
/rightarrow
 c 
/rightarrow
/rightarrow
 d 
/rightarrow
/rightarrow
 a) is not simple because path a 
/rightarrow
/rightarrow
 b 
/rightarrow
/rightarrow
 c 
/rightarrow
/rightarrow
 d (length 3) is longer than direct shortcut a 
/rightarrow
/rightarrow
 d (length 1).
\item \texttt{[b,e,d,c]} (from b 
/rightarrow
/rightarrow
 e 
/rightarrow
/rightarrow
 d 
/rightarrow
/rightarrow
 c 
/rightarrow
/rightarrow
 b) is not simple because path b 
/rightarrow
/rightarrow
 e 
/rightarrow
/rightarrow
 d 
/rightarrow
/rightarrow
 c (length 3) is longer than direct shortcut b 
/rightarrow
/rightarrow
 c (length 1, via arc 2).
\item The 2-cycles \texttt{[a,d]} (a 
/rightarrow
/rightarrow
 d, d 
/rightarrow
/rightarrow
 a), \texttt{[b,c]} (b 
/rightarrow
/rightarrow
 c, c 
/rightarrow
/rightarrow
 b), and \texttt{[c,d]} (c 
/rightarrow
/rightarrow
 d, d 
/rightarrow
/rightarrow
 c) are simple as their constituent 1-edge paths are inherently the shortest.
\end{itemize}
\end{itemize}
\section{Conclusion}
The Prolog program successfully implements an algorithm to find simple cycles in a directed graph based on the specified shortest path criterion. The interactive \texttt{main/0} predicate allows for easy testing with various predefined graph structures. It demonstrates the effective use of DFS for cycle detection, BFS for shortest path calculation, and Prolog's dynamic database capabilities and list manipulation features. The normalization step ensures that unique cycles are reported consistently, and \texttt{setof/3} provides a final, sorted list of these simple cycles.
\end{document}