:- dynamic node/2. % To store node information, like 'node(a, type1)'. Dynamic for test setups.
:- dynamic arc/4.  % To store directed graph arcs, e.g., 'arc(ID, Type, From, To)'. Dynamic for test setups.
:- dynamic edge/2. % A simplified 'edge(From, To)' relation, generated from arc/4 for faster lookups. Dynamic.

% --- Main Execution Block ---
main :-
    write('Select test case (1, 2, 3, or 4): '), % Prompting the user for which graph to test.
    read(N),
    (   setup_test(N) % Try to load the graph data for the chosen test case.
    ->  find_simple_cycles(SimpleCycles), % If successful, let's find those simple cycles.
        write('SimpleCycles = '), writeln(SimpleCycles) % And show them to the user.
    ;   write('Unknown test case!'), nl % Oops, bad number.
    ),
    halt. % All done.

% --- Utility: Generate simplified edge/2 facts from arc/4 ---
% We do this because arc/4 has extra info (ID, Type) we don't always need
% for basic graph traversal. edge/2 is just From-To.
generate_edges :-
    retractall(edge(_, _)), % Clean out any old edge facts first.
    forall(arc(_, _, N, M), % For every arc we have...
           assertz(edge(N, M))). % ...create a corresponding edge/2 fact.

% --- Test Case Data Setup ---
% These predicates define different graph structures for testing the cycle finding.
% Each one clears previous arc/4 data before asserting its own.

setup_test(1) :-
    retractall(arc(_,_,_,_)),
    % Test Case 1: A straightforward triangle: a -> b -> c -> a.
    assertz(arc(1, t, a, b)),
    assertz(arc(2, t, b, c)),
    assertz(arc(3, t, c, a)).

setup_test(2) :-
    retractall(arc(_,_,_,_)),
    % Test Case 2: A square (a-b-c-d-a) with a "chord" (b-d).
    % This should result in two simple cycles: a-b-d-a and b-c-d-b.
    % The cycle a-b-c-d-a is elementary but not simple because of the b-d chord.
    assertz(arc(1, t, a, b)),
    assertz(arc(2, t, b, c)),
    assertz(arc(3, t, c, d)),
    assertz(arc(4, t, d, a)),
    assertz(arc(5, t, b, d)). % The chord.

setup_test(3) :-
    retractall(arc(_,_,_,_)),
    % Test Case 3: A graph with a 2-cycle (a-b-a) and two separate triangles.
    % Expected: a-b-a, c-d-e-c, d-f-g-d.
    assertz(arc(1, t, a, b)), % Part of the 2-cycle
    assertz(arc(2, t, b, a)), % Completes the 2-cycle
    assertz(arc(3, t, c, d)), % Triangle 1
    assertz(arc(4, t, d, e)),
    assertz(arc(5, t, e, c)),
    assertz(arc(6, t, d, f)), % Triangle 2
    assertz(arc(7, t, f, g)),
    assertz(arc(8, t, g, d)).

setup_test(4) :-
    retractall(arc(_,_,_,_)),
    % Test Case 4: A more complex setup with overlapping cycles and a chord.
    % Cycle 1: a -> b -> c -> d -> a
    assertz(arc(1, t, a, b)),
    assertz(arc(2, t, b, c)),
    assertz(arc(3, t, c, d)),
    assertz(arc(4, t, d, a)),
    % Cycle 2: b -> e -> d -> c -> b (shares nodes/edges with Cycle 1)
    assertz(arc(5, t, b, e)),
    assertz(arc(6, t, e, d)),
    assertz(arc(7, t, d, c)), % Note: d-c is an edge here, c-d is in Cycle 1
    assertz(arc(8, t, c, b)), % Note: c-b is an edge here, b-c is in Cycle 1
    % A "short" chord: a -> d. This might make a-b-c-d-a non-simple.
    assertz(arc(9, t, a, d)).


find_simple_cycles(SimpleCycles) :-
    write('Initializing... Generating edge/2 facts...\n'), nl,
    generate_edges, % First, let's get those helper edge/2 facts ready.
    write('Finding all elementary cycles...\n'), nl,
    find_all_elementary_cycles(ElementaryCycles), % Now, find all cycles that don't repeat nodes (except start/end).
    length(ElementaryCycles, NumElementary),
    write('Found '), write(NumElementary), write(' elementary cycles.\n'), nl,
    % Let's see what elementary cycles we got, good for debugging.
    ( NumElementary > 0 ->
        print_cycles_list_reversed('Elementary Cycles Found (before filtering):', ElementaryCycles), % These are raw from DFS, so reversed.
        write('Filtering for "simple" cycles (this may take time)...\n'), nl,
        filter_simple_cycles(ElementaryCycles, NormalizedSimpleCycles), % This is the core logic: apply the "simple" definition.
        % Use setof to get unique, sorted (normalized) simple cycles.
        % The normalization is key for `setof` to correctly identify unique cycles.
        ( setof(NormCycle, Member^(member(Member, NormalizedSimpleCycles), NormCycle = Member), SimpleCycles) ->
            length(SimpleCycles, NumSimple),
            write('Found '), write(NumSimple), write(' simple cycles.\n'), nl,
            % And here's the final, filtered list.
            print_cycles_list('Simple Cycles Found (final result):', SimpleCycles)
        ;   write('Found 0 simple cycles after filtering.\n'), nl, % All candidates were filtered out.
            SimpleCycles = []
        )
    ;   write('No elementary cycles to filter.\n'), nl, % If we didn't find any elementary cycles to begin with.
        SimpleCycles = []
    ).

% --- Step 1: Find All Elementary Cycles (no repeated vertices except start/end) ---
% An elementary cycle is one where vertices are not repeated, except for the start/end vertex.
find_all_elementary_cycles(Cycles) :-
    findall(N, node(N, _), Nodes), % Get a list of all known nodes in the graph.
    find_cycles_starting_from_nodes(Nodes, Cycles). % Try to find cycles beginning at each of these nodes.

find_cycles_starting_from_nodes(Nodes, Cycles) :-
    findall( % Collect all cycles found.
        Cycle,
        (   member(StartNode, Nodes), % Pick a node to start from.
            edge(StartNode, Neighbor), % Find an edge leading out of it.
            % Start a Depth First Search from this Neighbor, trying to get back to StartNode.
            % PathSoFar is initialized with [Neighbor, StartNode] because DFS explores from Neighbor,
            % and StartNode is the target we want to reach.
            dfs_find_cycle(Neighbor, StartNode, [Neighbor, StartNode], Cycle)
        ),
        Cycles % The list of all cycles found.
    ).

dfs_find_cycle(CurrentNode, TargetNode, PathSoFar, Cycle) :-
    edge(CurrentNode, NextNode), % Try to move to an adjacent node.
    (   NextNode == TargetNode -> % Success! We've returned to the starting node of the cycle.
        % The PathSoFar is built in reverse order of traversal.
        % Cycle will be [TargetNode, NextNode_from_Target, ..., CurrentNode, TargetNode] if not careful with how it's passed.
        % Here, PathSoFar is [N_k, ..., N_1, StartNode], CurrentNode is N_k.
        % So [TargetNode | PathSoFar] gives [TargetNode, N_k, ..., N_1, TargetNode].
        % Oh, PathSoFar is [Current, Prev..., StartNode]. So if NextNode is TargetNode,
        % cycle is [TargetNode, Current, Prev..., StartNode]. This is correct for reverse path.
        Cycle = [TargetNode | PathSoFar]
    ;   \+ memberchk(NextNode, PathSoFar), % Crucial: don't visit a node already in the current path (prevents trivial loops / non-elementary).
        dfs_find_cycle(NextNode, TargetNode, [NextNode | PathSoFar], Cycle) % Continue exploring.
    ).

% --- Step 2: Filter Elementary Cycles to Get "Simple" Cycles ---
% A "simple" cycle is an elementary cycle where there's no "chord".
% That is, for any two nodes in the cycle, the shortest path between them
% in the *entire graph* is not shorter than their path along the cycle itself.

filter_simple_cycles([], []). % Base case: no more candidates to check.
filter_simple_cycles([Cycle | RestCandidates], [NormalizedCycle | SimpleRest]) :-
    is_simple_cycle(Cycle), % Check if this candidate elementary cycle is also "simple".
    !, % If it is, we commit to this path.
    normalize_cycle(Cycle, NormalizedCycle), % Standardize its representation for uniqueness.
    filter_simple_cycles(RestCandidates, SimpleRest). % And process the rest of the candidates.
filter_simple_cycles([_Cycle | RestCandidates], SimpleRest) :-
    % If the above clause failed (is_simple_cycle was false), this one is tried.
    % This means _Cycle was not simple, so we discard it and move on.
    filter_simple_cycles(RestCandidates, SimpleRest).

is_simple_cycle(Cycle) :-
    % Cycle from DFS is in reverse: [Start, NodeK, ..., Node1, Start].
    % We need the nodes in forward traversal order, without the repeated start node at the end.
    reverse(Cycle, ForwardCycleWithRepeatEnd), % e.g., [a,b,c,a] from DFS's [a,c,b,a]
    ForwardCycleWithRepeatEnd = [StartNode | PathNodesWithRepeatEnd], % StartNode=a, PathNodesWithRepeatEnd=[b,c,a]
    append(PathNodesUnique, [StartNode], PathNodesWithRepeatEnd), % PathNodesUnique=[b,c]
    NodesInCycleOrdered = [StartNode | PathNodesUnique], % This is the list of unique nodes in the cycle, in order, e.g., [a,b,c].

    % Now, for every pair of nodes (N1, N2) in this cycle, the shortest path in the
    % graph must not be shorter than their path along this cycle's edges.
    check_all_pairs_shortest_path(NodesInCycleOrdered, NodesInCycleOrdered).

check_all_pairs_shortest_path([], _). % Base case: all N1s have been processed.
check_all_pairs_shortest_path([N1 | RestN1], OriginalCycleNodes) :-
    % For the current N1, check its "simple path" condition against all N2 in OriginalCycleNodes.
    check_pairs_from_node(N1, OriginalCycleNodes, OriginalCycleNodes),
    check_all_pairs_shortest_path(RestN1, OriginalCycleNodes). % Then, do the same for the next N1.

check_pairs_from_node(_, [], _). % Base case: N1 has been checked against all N2s.
check_pairs_from_node(N1, [N2 | RestN2], OriginalCycleNodes) :-
    ( N1 == N2 -> true % A node to itself, distance is 0. This pair is fine.
    ;   % Calculate distance between N1 and N2 *along the current cycle path*.
        get_cycle_distance(N1, N2, OriginalCycleNodes, CycleDist),
        % Find the absolute shortest path between N1 and N2 in the *entire graph*.
        shortest_path_length(N1, N2, ShortestDist),
        % The "simple" condition:
        ( ShortestDist == -1 -> % If no path exists at all in the graph (shouldn't happen if they are in a cycle).
                                % This implies an issue unless CycleDist is also effectively infinite or 0.
                                % For a valid cycle path, CycleDist > 0. If no other path, it's simple.
           (CycleDist > 0 -> true ; !, fail)
        ; ShortestDist >= CycleDist % The shortest path in graph must be >= path along cycle. If shorter, it's a "chord".
        )
    ),
    !, % If the check for this N1-N2 pair succeeded, commit.
    check_pairs_from_node(N1, RestN2, OriginalCycleNodes). % Check N1 against the next N2.
check_pairs_from_node(_, _, _) :- !, fail. % If any N1-N2 pair fails the condition, this predicate fails (cycle is not simple).

get_cycle_distance(NodeA, NodeB, CycleNodes, Distance) :-
    % Calculates distance (number of edges) between NodeA and NodeB strictly following the CycleNodes list.
    % CycleNodes is like [n1, n2, n3, n4] for cycle n1-n2-n3-n4-n1.
    nth0(IndexA, CycleNodes, NodeA), % Find 0-based index of NodeA.
    nth0(IndexB, CycleNodes, NodeB), % Find 0-based index of NodeB.
    length(CycleNodes, Len), % Total number of nodes in the cycle path.
    ( IndexB >= IndexA -> % If NodeB is at or after NodeA in the list.
        Distance is IndexB - IndexA % Straightforward difference.
    ; % NodeB is before NodeA, meaning we "wrap around" the cycle.
      % E.g., in [a,b,c,d], distance from d (idx 3) to b (idx 1):
      % (Len - IndexA) is path from d to end-then-start (d-a), then + IndexB (a-b).
      % (4 - 3) + 1 = 1 + 1 = 2. (Path d-a-b).
        Distance is Len - IndexA + IndexB
    ).

% --- Utility: Find Shortest Path Length (using BFS) ---
% This finds the length of the shortest path between two nodes in the entire graph,
% considering all available edges (not just those in a specific cycle).
shortest_path_length(Start, End, Length) :-
    bfs([[Start, 0]], End, [Start], Length), % Initial queue: [[Node, DistanceFromStart]], VisitedList
    !. % Found a path, commit.
shortest_path_length(_, _, -1). % If bfs fails (first clause cut ensures this is only tried on failure), no path exists.

bfs([], _, _, _) :- !, fail. % Queue is empty, but target not found. No path.
bfs([[Target, Length] | _], Target, _, Length) :- !. % Target is at the head of the queue. We found it! Length is its distance.
bfs([[Current, Dist] | RestQueue], Target, Visited, Length) :-
    % Dequeue [Current, Dist]. Find its unvisited neighbors.
    findall(Next, (edge(Current, Next), \+ member(Next, Visited)), Neighbors),
    NewDist is Dist + 1, % Neighbors are one step further.
    add_neighbors_to_queue(Neighbors, NewDist, RestQueue, NewQueue), % Prepare new queue entries and add to *end* of queue (BFS).
    append(Visited, Neighbors, NewVisitedCombined), % Add newly found neighbors to the visited list.
    list_to_set(NewVisitedCombined, NewVisitedUnique), % Make sure visited list stays unique (SWI-Prolog's list_to_set).
    bfs(NewQueue, Target, NewVisitedUnique, Length). % Continue search.

add_neighbors_to_queue(Neighbors, Distance, CurrentQueue, NewQueue) :-
    % Helper to package neighbors as [Node, Distance] and append them to the existing queue.
    findall([N, Distance], member(N, Neighbors), NeighborEntries),
    append(CurrentQueue, NeighborEntries, NewQueue). % Appending to end makes it BFS.

% --- Utility: Normalize Cycle Representation for Uniqueness ---
% Normalization means representing a cycle in a canonical way, typically by
% starting with its lexicographically smallest node and listing nodes in traversal order.
% This helps in identifying unique cycles, as DFS might find the same cycle
% starting from different nodes or (if undirected, though here it's directed) in reverse.

% normalize_cycle(+RawCycle, -NormalizedNodeList)
% Input RawCycle from DFS is like [a, d, c, b, a] (last node is start, path nodes are in reverse traversal order).
% Output NormalizedNodeList should be like [a, b, c, d] (forward order, starts from lexicographically
% smallest node in the cycle, and the duplicate end node is removed).
normalize_cycle(RawCycle, NormalizedNodeList) :-
    RawCycle = [StartNode | ReversedPathWithStart], % E.g., StartNode=a, ReversedPathWithStart=[d, c, b, a]
    % ReversedPathWithStart has the path nodes in reverse order, ending with StartNode again.
    % We want the forward path nodes, without the repeated StartNode.
    reverse(ReversedPathWithStart, [_DroppedRedundantStartNode | ForwardPathNodes]), % e.g., ForwardPathNodes=[b, c, d] after 'a' is dropped
    ForwardCycleNodes = [StartNode | ForwardPathNodes], % Full cycle node list in forward order, e.g., [a, b, c, d]
    find_min_node(ForwardCycleNodes, MinNode), % Find the 'smallest' node (e.g., 'a' if it's 'a', 'b', 'c').
    rotate_list_to_start_with(ForwardCycleNodes, MinNode, NormalizedNodeList). % Rotate list so MinNode is first.

find_min_node([M], M) :- !. % Base case: list with one element, that's the minimum.
find_min_node([H | T], Min) :-
    find_min_node(T, MinTail), % Find minimum in the rest of the list.
    ( H @< MinTail -> Min = H ; Min = MinTail ).  % Compare head with min_of_tail. `@<` is standard term comparison for atoms.

rotate_list_to_start_with(List, Element, RotatedList) :-
    % Rotates 'List' so that 'Element' becomes the first item.
    % e.g., rotate_list_to_start_with([b,c,d,a], a, RotatedList) -> RotatedList = [a,b,c,d]
    append(BeforeElement, [Element | AfterElement], List), % Split the list at 'Element'.
    !, % Found the element, commit to this way of splitting.
    append([Element | AfterElement], BeforeElement, RotatedList). % New list is Element, what came after, then what came before.
rotate_list_to_start_with(List, _, List). % Fallback: If Element is already first, or not found (shouldn't happen here),
                                          % the first clause's append might behave such that 'BeforeElement' is empty.
                                          % This second clause acts as a safety or for when Element is already first.

% --- Helper Predicates for Printing ---
print_cycles_list(_, []) :- !. % If there's nothing to print, do nothing.
print_cycles_list(Header, ListOfCycles) :-
    writeln(Header), % Print the supplied title.
    forall(member(Cycle, ListOfCycles), (write('  '), writeln(Cycle))). % Print each cycle indented.

print_cycles_list_reversed(Header, Cycles) :-
    % Used for printing elementary cycles which are found by DFS in reverse order of traversal.
    % Reversing them shows the path as it would be traversed.
    writeln(Header),
    forall(member(Cycle, Cycles), (
       reverse(Cycle, ForwardCycle), % Turn it around.
       write('  '), writeln(ForwardCycle)
    )).

% --- Default Node Declarations (if not provided by test cases) ---
% These ensure that `node/2` facts exist, which `find_all_elementary_cycles` uses
% to get a list of all nodes to start cycle searches from.
% Test cases might assert their own nodes, or rely on these.
node(a, type1).
node(b, type1).
node(c, type1).
node(d, type1).
node(e, type1).
node(f, type1).
node(g, type1).