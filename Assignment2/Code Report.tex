\documentclass[11pt, a4paper]{article}

% --- Standard Packages ---
\usepackage[utf8]{inputenc} % UTF-8 input encoding
\usepackage[T1]{fontenc}    % T1 font encoding for better character rendering
\usepackage[english]{babel} % Set language to English (hyphenation, section names)
\usepackage{geometry}       % For setting margins
\usepackage{amsmath}        % For advanced math commands (good practice)
\usepackage{graphicx}       % For including images (not used here)
\usepackage{hyperref}       % For creating internal and external links
\usepackage{lmodern}        % Use Latin Modern font (better than Computer Modern)
\usepackage{listings}       % For including source code (configured but not actively used to show code)
\usepackage{datetime}       % For the current date

% --- Page Settings ---
\geometry{
  a4paper,
  left=2.5cm,
  right=2.5cm,
  top=3cm,
  bottom=3cm
}

% --- Listings Settings (if code were displayed) ---
\lstset{
  language=Java,
  basicstyle=\ttfamily\small, % Font and size for code
  keywordstyle=\color{blue},
  commentstyle=\color{green!60!black},
  stringstyle=\color{red},
  showstringspaces=false,
  breaklines=true,
  frame=single,
  numbers=left,
  numberstyle=\tiny\color{gray}
}

% --- Hyperref Settings ---
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,
    urlcolor=cyan,
    pdftitle={Analysis Report for CsvToJsonConverter Code},
    pdfpagemode=FullScreen,
}

% --- Document Information ---
\title{Analysis Report: Java Code \texttt{CsvToJsonConverter}}
% \author{Project Team} % Or remove entirely
\date{\today}

\begin{document}

\maketitle
\thispagestyle{empty} % No page number on the title page

\newpage
\tableofcontents % Generate table of contents
\thispagestyle{empty} % No page number on the ToC page

\newpage
\setcounter{page}{1} % Start page numbering from 1

% --- Introduction ---
\section{Introduction}
This report describes the Java code provided in the \texttt{CsvToJsonConverter} package. Its objective is to explain in detail the purpose of the code, its functionality, and provide a higher-level overview of its implementation. The code is designed to read data from a CSV file, interpret it according to specific logic, transform it into a structured data model (entities and relationships), and finally serialize this model into a JSON file.

% --- Purpose of the Code ---
\section{Purpose of the Code}
The primary purpose of the \texttt{CsvToJsonConverter} code is to **convert a data catalog stored in a tabular CSV (Comma Separated Values) format into a hierarchical and structured JSON (JavaScript Object Notation) format**.

More specifically, the code aims to:
\begin{itemize}
    \item Read data from a specific CSV file (\texttt{HCLEcatalog.csv}).
    \item Interpret each CSV row as representing an entity (such as a physical object, document, person, organization, etc.) or containing information that defines entities and relationships.
    \item Extract and map data from CSV columns to the fields of well-defined Java objects (POJOs - Plain Old Java Objects).
    \item Classify the main entities into specific types (e.g., \texttt{Item}, \texttt{Document}, \texttt{Artifact}) based on the presence or format of certain fields in the CSV.
    \item Identify and create related entities such as persons (\texttt{Person}), organizations (\texttt{Organization}), categories (\texttt{Category}), and materials (\texttt{Material}) from data in other columns (e.g., \texttt{Creator}, \texttt{SubjectTop}, \texttt{Material}).
    \item Establish meaningful relationships between these entities (e.g., an \texttt{Item} "belongsTo" a collection, a \texttt{Document} is "developed by" a \texttt{Person}, an \texttt{Item} is "madeOf" a \texttt{Material}).
    \item Ensure the uniqueness of the extracted entities and relationships (avoiding duplicates).
    \item Generate a log file (\texttt{parsing.log}) that tracks the processing status and reports any errors or warnings for each CSV row.
    \item Produce a final JSON file (\texttt{data.json}) representing all unique entities and their relationships in a well-defined structure, suitable for further processing, analysis, or integration with other systems (e.g., graph databases, web applications).
\end{itemize}
In summary, the code acts as a bridge between a tabular and potentially flat data format (CSV) and a structured, relational data format (JSON), applying domain-specific interpretation and classification logic based on the data within the CSV.

% --- Main Functionality (What it Does) ---
\section{Main Functionality (What it Does)}
The code executes a series of logical steps to achieve its purpose:

\begin{enumerate}
    \item \textbf{CSV Reading and Parsing:}
        \begin{itemize}
            \item Opens the specified CSV file (\texttt{HCLEcatalog.csv}) using UTF-8 encoding.
            \item Utilizes the Apache Commons CSV library to interpret the file.
            \item Recognizes the first row as the header, ignoring case in column names.
            \item Trims leading and trailing whitespace from each read value.
            \item Iterates over each record (row) in the CSV file, excluding the header.
        \end{itemize}

    \item \textbf{Row Validation and Data Extraction:}
        \begin{itemize}
            \item For each row, extracts the value from the \texttt{IdNum} column. If it is missing or empty, the row is skipped, and an error is logged.
            \item Extracts values from all other columns defined in the header and stores them in a map (\texttt{Map<String, String>}) for easy access.
            \item Performs basic cleaning (e.g., removing residual quotation marks).
        \end{itemize}

    \item \textbf{Determining the Main Entity Type:}
        \begin{itemize}
            \item Checks if the row represents a \texttt{Document} by verifying the presence of non-null/empty/"None" values in the \texttt{ToC}, \texttt{Extent}, \texttt{SerialNum}, or \texttt{BibCit} columns.
            \item If it is not a \texttt{Document}, checks if it is an \texttt{Item} by verifying that the \texttt{PartNum} column contains a non-null/empty/"None" value and that it is not a single digit.
            \item If it meets neither the criteria for \texttt{Document} nor \texttt{Item}, it is classified as a generic \texttt{Artifact}.
            \item Verifies the presence of the mandatory \texttt{Title} field. If missing, the row is discarded, and an error is logged.
        \end{itemize}

    \item \textbf{Creating the Main Entity Object:}
        \begin{itemize}
            \item Instantiates a Java object of the appropriate class (\texttt{Document}, \texttt{Item}, or \texttt{Artifact}).
            \item Populates the object's fields with values extracted from the corresponding CSV columns (e.g., \texttt{title}, \texttt{description}, \texttt{partNum}, \texttt{toC}, \texttt{created}, etc.).
            \item Applies specific logic for certain fields:
                \begin{itemize}
                    \item For \texttt{Document.created}, uses the value from \texttt{Created} if present, otherwise falls back to \texttt{DateCR}.
                    \item For \texttt{Document.copyrighted}, converts 'y' to \texttt{true}, 'n' or '0' to \texttt{false}, leaving it \texttt{null} otherwise.
                    \item Excludes fields if their value in the CSV is null, empty, or "None" (handled by \texttt{@JsonInclude(Include.NON\_NULL)} and \texttt{isNullOrNone} checks).
                \end{itemize}
        \end{itemize}

    \item \textbf{Identifying and Creating Related Entities:}
        \begin{itemize}
            \item \textbf{Material:} If the \texttt{Material} column contains 'papr', 'digi', or 'mix', creates a \texttt{Material} object with the corresponding name ("paper", "digital", "mix"). Unrecognized codes are logged as warnings.
            \item \textbf{Category:} If the \texttt{SubjectTop} column has a value, creates a \texttt{Category} object using that value as the name.
            \item \textbf{Person/Organization (from Creator):}
                \begin{itemize}
                    \item Attempts to interpret the value of the \texttt{Creator} column as a person's name using a specific regex (\texttt{PERSON\_REGEX\_STRICT}) and the \texttt{parsePerson} method.
                    \item If interpretation succeeds, creates a \texttt{Person} object with separate name and surname.
                    \item Otherwise (if the regex does not match or parsing fails), creates an \texttt{Organization} object using the original value as the name.
                \end{itemize}
            \item \textbf{Person/Organization (from Contributor/AddlAuth):}
                \begin{itemize}
                    \item Uses a dedicated method (\texttt{processContributorField}) to handle the \texttt{Contributor} and \texttt{AddlAuth} columns.
                    \item These fields can contain multiple names separated by commas, semicolons, "and", or "&".
                    \item The method identifies if the field contains a list of person names (\texttt{PERSON\_REGEX\_LIST}).
                    \item If so, it splits the string and attempts to parse each part as a \texttt{Person}. If parsing fails for a part, it treats that part as an \texttt{Organization}.
                    \item If the field does not resemble a list of persons, it treats the entire content as a single \texttt{Organization}.
                    \item Creates the corresponding \texttt{Person} or \texttt{Organization} objects.
                \end{itemize}
        \end{itemize}

    \item \textbf{Uniqueness Management:}
        \begin{itemize}
            \item Utilizes \texttt{HashSet} collections to store all entities (\texttt{Item}, \texttt{Document}, \texttt{Artifact}, \texttt{Person}, \texttt{Organization}, \texttt{Category}, \texttt{Material}) and relationships (\texttt{Relationship}).
            \item Due to the correct implementation of \texttt{equals()} and \texttt{hashCode()} methods in the POJO classes, adding an element to a \texttt{Set} only succeeds if an equal element does not already exist, thus ensuring uniqueness.
        \end{itemize}

    \item \textbf{Relationship Creation:}
        \begin{itemize}
            \item For every valid main entity extracted from a CSV row, creates a \textbf{\texttt{belongsTo}} relationship:
                \begin{itemize}
                    \item Subject: The fixed collection "HCLE" (Type: \texttt{Collection}).
                    \item Object: The current entity (identified by title, or title + PartNum for Items). Type: \texttt{Item}, \texttt{Document}, or \texttt{Artifact}.
                    \item Includes the original \texttt{IdNum} value in this relationship's \texttt{number} field.
                \end{itemize}
            \item If a \texttt{Material} is identified for an \texttt{Item}, creates a \textbf{\texttt{madeOf}} relationship:
                \begin{itemize}
                    \item Subject: The current Item. Type: \texttt{Item}.
                    \item Object: The identified Material. Type: \texttt{Material}.
                \end{itemize}
            \item If a \texttt{Category} is identified for a \texttt{Document} or \texttt{Artifact}, creates a \textbf{\texttt{describe}} relationship:
                \begin{itemize}
                    \item Subject: The identified Category. Type: \texttt{Category}.
                    \item Object: The current Document/Artifact. Type: \texttt{Document} or \texttt{Artifact}.
                \end{itemize}
            \item If a \texttt{Creator} is identified for a \texttt{Document} or \texttt{Artifact}:
                \begin{itemize}
                    \item If it is a \texttt{Person}, creates a \textbf{\texttt{developed}} relationship. Subject: Person, Object: Document/Artifact.
                    \item If it is an \texttt{Organization}, creates a \textbf{\texttt{produced}} relationship. Subject: Organization, Object: Document/Artifact.
                \end{itemize}
            \item For each \texttt{Person} or \texttt{Organization} identified from the \texttt{Contributor} or \texttt{AddlAuth} fields, creates appropriate relationships:
                \begin{itemize}
                    \item From \texttt{Contributor}: Base type \textbf{\texttt{developed}} (becomes \textbf{\texttt{produced}} for Organizations). Subject: Person/Organization, Object: Current entity.
                    \item From \texttt{AddlAuth}: Base type \textbf{\texttt{collaborated}}. Subject: Person/Organization, Object: Current entity.
                \end{itemize}
        \end{itemize}

    \item \textbf{Logging:}
        \begin{itemize}
            \item Opens and writes to a log file (\texttt{parsing.log}) using UTF-8 encoding.
            \item Logs the start of processing for each row, indicating the identified entity type, ID, and title.
            \item Logs critical errors (e.g., missing \texttt{IdNum}, missing \texttt{Title}) that cause the row to be skipped.
            \item Logs warnings (e.g., unrecognized \texttt{Material} code, failure to parse a name as a \texttt{Person}).
            \item Logs the completion of processing for each row.
            \item At the end, logs summary statistics on the number of unique entities and relationships found.
        \end{itemize}

    \item \textbf{JSON Output Generation:}
        \begin{itemize}
            \item Collects all unique entities from the \texttt{Set}s and organizes them into lists within an \texttt{Entities} object. This object also contains the collection information ("HCLE").
            \item Collects all unique relationships from the relationship \texttt{Set}.
            \item Filters the relationships, discarding those that lack valid (non-null and non-empty) values for essential fields (\texttt{ontology}, \texttt{type}, \texttt{subject}, \texttt{subjectType}, \texttt{object}, \texttt{objectType}). The \texttt{number} field can be null.
            \item Creates a root \texttt{JsonOutput} object containing the \texttt{Entities} object and the filtered list of \texttt{Relationship}s.
            \item Uses the Jackson library (\texttt{ObjectMapper}) to serialize the \texttt{JsonOutput} object into a JSON string.
            \item Configures Jackson to produce formatted ("pretty-print") JSON output for better readability.
            \item Writes the resulting JSON string to the specified output file (e.g., \texttt{data.json}) using UTF-8 encoding.
        \end{itemize}

    \item \textbf{Error Handling:}
        \begin{itemize}
            \item Uses try-with-resources blocks to ensure automatic closing of files (CSV, log, JSON).
            \item Catches \texttt{IOException} that may occur during file I/O operations or CSV parsing.
            \item Catches generic \texttt{Exception}s to handle unexpected errors during processing.
            \item Prints error messages to the standard error console (\texttt{System.err}) in case of severe exceptions.
        \end{itemize}
\end{enumerate}

% --- Implementation Overview (How it Works) ---
\section{Implementation Overview (How it Works)}
This section provides a high-level view of how the code achieves the described functionality.

\begin{itemize}
    \item \textbf{External Libraries:} The code relies on two main external libraries:
        \begin{itemize}
            \item \textbf{Apache Commons CSV:} Used for robust and configurable reading of CSV files, automatically handling headers, delimiters, quoting, and value trimming.
            \item \textbf{Jackson Databind:} A powerful library for handling the JSON format in Java. It is used to serialize the Java objects (POJOs) into the desired JSON structure, managing the mapping between Java fields and JSON keys via annotations (\texttt{@JsonProperty}, \texttt{@JsonInclude}, \texttt{@JsonIgnore}) and \texttt{ObjectMapper} configuration.
        \end{itemize}

    \item \textbf{POJO-Based Structure:} The core of the data representation consists of Plain Old Java Objects (POJOs) modeling the different entities (\texttt{Artifact}, \texttt{Item}, \texttt{Document}, \texttt{Person}, etc.) and relationships (\texttt{Relationship}). These classes contain public fields (or getters/setters, though omitted for brevity here) annotated with \texttt{@JsonProperty} to control JSON serialization. Inheritance (\texttt{Item} and \texttt{Document} extend \texttt{Artifact}, which extends \texttt{BaseEntity}) facilitates sharing common properties. The implementation of \texttt{equals()} and \texttt{hashCode()} is crucial for using \texttt{Set}s to ensure uniqueness.

    \item \textbf{Main Class and Control Flow:} The \texttt{CsvToJsonConverter} class contains the \texttt{main} method, which orchestrates the entire process. The main flow involves a loop iterating over CSV records. Inside the loop, helper methods are invoked to perform specific tasks like safe value extraction (\texttt{getRecordValue}), validation (\texttt{isNullOrNone}, \texttt{isNullOrEmpty}), name parsing (\texttt{parsePerson}), and handling fields with multiple contributors (\texttt{processContributorField}).

    \item \textbf{Conditional Logic and Regex:} Entity classification (Item vs. Document vs. Artifact) and the identification of Persons vs. Organizations rely on conditional logic (\texttt{if-else}) checking the presence and format of data in specific CSV columns. Regular expressions (Regex) are used purposefully (\texttt{PERSON\_REGEX\_STRICT}, \texttt{PERSON\_REGEX\_LIST}, \texttt{NAME\_SPLIT\_DELIMITER}) to identify specific patterns in person names and to split strings containing multiple names.

    \item \textbf{Use of Standard Collections:} The code makes extensive use of standard Java collections:
        \begin{itemize}
            \item \texttt{Map<String, String>}: To store data from a CSV row accessible by header name.
            \item \texttt{Set<E>}: Fundamental for collecting unique entities and relationships.
            \item \texttt{List<E>}: Used in the final structure (\texttt{Entities}, \texttt{JsonOutput}) to hold the collections of entities and relationships for JSON serialization (Jackson works more naturally with lists for JSON arrays). Conversion from Set to List occurs before serialization.
        \end{itemize}

    \item \textbf{File and Resource Management:} The use of try-with-resources ensures that files and streams (readers, parsers, writers) are closed correctly even if errors occur, preventing resource leaks. Specifying UTF-8 encoding is important for handling special characters correctly.
\end{itemize}

% --- Definition of Entities and Relationships ---
\section{Definition of Entities and Relationships}
The code defines the following main data structures (POJOs) to represent the extracted data and their connections:

\begin{itemize}
    \item \textbf{\texttt{BaseEntity}}: Abstract base class with common fields \texttt{ontology} (default "General") and \texttt{entityType}.
    \item \textbf{\texttt{Artifact}}: Represents a generic artifact. Includes \texttt{title}, \texttt{description}, \texttt{descComment}, \texttt{wherMade}. \texttt{entityType} is "Artifact".
    \item \textbf{\texttt{Item}}: Subclass of \texttt{Artifact}. Represents a physical object, typically with a part number. Adds \texttt{partNum} and \texttt{conditionNts}. \texttt{entityType} is "Item".
    \item \textbf{\texttt{Document}}: Subclass of \texttt{Artifact}. Represents a document. Adds \texttt{toC}, \texttt{extent}, \texttt{serialNum}, \texttt{bibCit}, \texttt{created}, \texttt{copyrighted}. \texttt{entityType} is "Document".
    \item \textbf{\texttt{Person}}: Represents a physical person. Includes \texttt{name} (first name) and \texttt{surname} (last name). \texttt{entityType} is "Agent:Person".
    \item \textbf{\texttt{Organization}}: Represents an organization. Includes \texttt{name}. \texttt{entityType} is "Agent:Organization".
    \item \textbf{\texttt{Category}}: Represents a category or subject (from \texttt{SubjectTop}). Includes \texttt{name}. \texttt{entityType} is "ContentDescription:Category".
    \item \textbf{\texttt{Material}}: Represents the material an Item is made of (from \texttt{Material}). Includes \texttt{name}. \texttt{entityType} is "Material".
    \item \textbf{\texttt{Relationship}}: Represents a connection between two entities. Includes \texttt{type} (relationship type), \texttt{subject} (subject entity ID), \texttt{subjectType} (subject entity type), \texttt{object} (object entity ID), \texttt{objectType} (object entity type), and optionally \texttt{number} (for \texttt{IdNum}).
    \item \textbf{\texttt{CollectionInfo}}: Represents information about the main collection ("HCLE").
    \item \textbf{\texttt{Entities}}: Container grouping lists of all unique entities (\texttt{Items}, \texttt{Documents}, \texttt{People}, etc.) and the \texttt{CollectionInfo} object.
    \item \textbf{\texttt{JsonOutput}}: Root object for the JSON output, contains the \texttt{Entities} and the list of \texttt{Relationships}.
\end{itemize}
Jackson annotations (\texttt{@JsonProperty}, \texttt{@JsonInclude}) control how these objects are transformed into JSON.

% --- Conclusion ---
\section{Conclusion}
The \texttt{CsvToJsonConverter} code is a specialized ETL (Extract, Transform, Load) tool that performs the conversion of data from a specific CSV file to a structured JSON format. It achieves this by reading the CSV, applying business rules to interpret and classify data into distinct entities, identifying and creating related entities, establishing relationships between them, ensuring data uniqueness, and finally serializing the result into JSON. It also produces a detailed process log. The use of standard libraries (Apache Commons CSV, Jackson) and a POJO-based design makes it relatively maintainable and understandable, although the interpretation logic is tightly coupled to the expected structure and semantics of the input CSV file.

\end{document}